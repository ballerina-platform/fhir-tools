##/*
##* Copyright (c) 2024, WSO2 LLC. (http://www.wso2.org).
##*
##* WSO2 LLC. licenses this file to you under the Apache License,
##* Version 2.0 (the "License"); you may not use this file except
##* in compliance with the License.
##* You may obtain a copy of the License at
##*
##* http://www.apache.org/licenses/LICENSE-2.0
##*
##* Unless required by applicable law or agreed to in writing,
##* software distributed under the License is distributed on an
##* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
##* KIND, either express or implied. See the License for the
##* specific language governing permissions and limitations
##* under the License.
##*/

import ballerina/http;
import ballerina/lang.regexp;
import ballerinax/health.fhir.cds;

service class ResponseErrorInterceptor {
    *http:ResponseErrorInterceptor;

    remote function interceptResponseError(error err, http:Response response) returns http:Response {
        if (response.statusCode == 400) {
            string message = err.message();
            regexp:Span? search = regexp:find(re `field\s'[^']*'\scannot\sbe\sadded\sto\sthe\sclosed\srecord`, message);
            if search is regexp:Span {
                string[] split = regexp:split(re `'`, search.substring());
                if (split.length() > 1) {
                response.setJsonPayload({
                "message": string `Unknown field ${split[1]}`
                }, "application/json");
                }
            }
        } else {
            response.setJsonPayload({
                "message": err.message()
            }, "application/json");
        }
        return response;
    }
}


service class RequestInterceptor {
    *http:RequestInterceptor;

    resource function 'default cds\-services/[string hook_id](http:RequestContext ctx, http:Request re) returns http:NextService|http:Response|error? {
        json|http:ClientError jsonPayload = re.getJsonPayload();
        if jsonPayload is http:ClientError {
            cds:CdsError cdsError = cds:createCdsError("Provided payload is not a JSON", 400);
            return cds:cdsErrorToHttpResponse(cdsError);
        }

        cds:CdsRequest|error cdsRequest = jsonPayload.cloneWithType(cds:CdsRequest);
        if cdsRequest is error {
            regexp:Span? search = regexp:find(re `field\s'[^']*'\scannot\sbe\sadded\sto\sthe\sclosed\srecord`, cdsRequest.message());
            if search is regexp:Span {
            string[] split = regexp:split(re `'`, search.substring());
            if (split.length() > 1) {
                cds:CdsError cdsError = cds:createCdsError(
                string `Unknown field ${split[1]}`,
                400,
                description = "Provided payload is not a proper CDS request. Please validate your request payload with the format mentioned in the official specification: https://cds-hooks.hl7.org/2.0/#http-request_1"
                );
                return cds:cdsErrorToHttpResponse(cdsError);
            }
        }

        cds:CdsError cdsError = cds:createCdsError(
        "Provided payload is not a proper CDS request.",
        400,
        description = "Please validate your request payload with the format mentioned in the official specification: https://cds-hooks.hl7.org/2.0/#http-request_1");
        return cds:cdsErrorToHttpResponse(cdsError);
    }

    cds:CdsRequest|http:Response preProcessingResult = preProcessing(hook_id, cdsRequest);
    if preProcessingResult is http:Response {
        return preProcessingResult;
    }

    return check ctx.next();
    }
}
